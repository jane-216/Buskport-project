import { db } from './db.js';

/** ---------------------------------------------
 * Types (JSDoc to keep JS runtime + strong hints)
 * ----------------------------------------------*/

/**
 * @typedef {'Listing'|'Sales'|'Social'|'Onboarding'|'Streak'|string} AchievementCategory
 */

/**
 * A normalized check result so downstream code never branches on boolean.
 * `done` indicates unlock; `progress` and `target` are always numbers (>=0).
 * @typedef {{ done: boolean; progress: number; target: number }} AchievementCheckResult
 */

/**
 * @typedef {{
 *  id: string;
 *  key?: string;
 *  name: string;
 *  description: string;
 *  points: number;
 *  icon: string;
 *  category: AchievementCategory;
 *  secret?: boolean;
 *  metric: string;
 *  threshold: number;
 *  check: (s: Record<string, number>) => AchievementCheckResult;
 * }} AchievementRule
 */

/** ---------------------------------------------
 * Utilities
 * ----------------------------------------------*/

/** Coerce to a non-negative number; returns 0 if NaN/negative/undefined. */
function safeNumber(val) {
  const n = Number(val);
  return Number.isFinite(n) && n > 0 ? n : 0;
}

/** Create a unified check that always returns {done, progress, target}. */
function makeCheck(metric, threshold) {
  const tgt = Math.max(0, Number(threshold) || 0);
  return (s) => {
    const cur = safeNumber(s?.[metric]);
    return { done: cur >= tgt, progress: cur, target: tgt };
  };
}

/**
 * DRY rule factory with minimal validation; normalization happens later.
 * Keeping the surface area small improves readability at call sites.
 */
function makeRule({
  id, name, description, points, icon, category,
  metric, threshold, secret = false, key,
}) {
  return {
    id,
    key: key ?? id,
    name,
    description,
    points,
    icon,
    category,
    secret,
    metric,
    threshold,
    check: makeCheck(metric, threshold),
  };
}

/** ---------------------------------------------
 * Rule Definitions
 * ----------------------------------------------*/

export const RULES = [
  makeRule({
    id: 'five_listings',
    name: 'íŒë§¤ ì¤€ë¹„ (ë“±ë¡)',
    description: 'íŒë§¤ê¸€ì„ ë“±ë¡í–ˆì–´ìš”.',
    points: 15,
    icon: 'ğŸ–ï¸',
    category: 'Listing',
    metric: 'listings',
    threshold: 5,
  }),
  makeRule({
    id: 'first_sale',
    name: 'ì²« íŒë§¤',
    description: 'ì²˜ìŒ ê±°ë˜ë¥¼ ì„±ê³µí–ˆì–´ìš”.',
    points: 25,
    icon: 'ğŸ’¸',
    category: 'Sales',
    metric: 'sales',
    threshold: 1,
  }),
  makeRule({
    id: 'five_sales',
    name: 'ê±°ë˜ ì¥ì¸ (5íšŒ)',
    description: '5íšŒ ê±°ë˜ë¥¼ í–ˆì–´ìš”.',
    points: 50,
    icon: 'ğŸ¥‡',
    category: 'Sales',
    metric: 'sales',
    threshold: 5,
  }),
  makeRule({
    id: 'ten_chats',
    name: 'ì†Œí†µì™• (10íšŒ ì±„íŒ…)',
    description: '10ë²ˆì˜ ì±„íŒ…ì„ ì‹œì‘í–ˆì–´ìš”.',
    points: 15,
    icon: 'ğŸ’¬',
    category: 'Social',
    metric: 'chats',
    threshold: 10,
  }),
  makeRule({
    id: 'profile_complete',
    name: 'í”„ë¡œí•„ 100% ì™„ë£Œ',
    description: 'í”„ë¡œí•„ ì •ë³´ë¥¼ ëª¨ë‘ ì±„ì› ì–´ìš”.',
    points: 10,
    icon: 'ğŸ§‘â€ğŸ’¼',
    category: 'Onboarding',
    metric: 'profile_completed',
    threshold: 1,
  }),
  makeRule({
    id: 'login_streak_3',
    name: '3ì¼ ì—°ì† ì ‘ì†',
    description: '3ì¼ ì—°ì†ìœ¼ë¡œ ì ‘ì†í–ˆì–´ìš”.',
    points: 20,
    icon: 'ğŸ”¥',
    category: 'Streak',
    metric: 'login_streak',
    threshold: 3,
  }),
  makeRule({
    id: 'login_streak_7',
    name: '7ì¼ ì—°ì† ì ‘ì†',
    description: '7ì¼ ì—°ì†ìœ¼ë¡œ ì ‘ì†í–ˆì–´ìš”.',
    points: 40,
    icon: 'âš¡',
    category: 'Streak',
    metric: 'login_streak',
    threshold: 7,
  }),
];

/** ---------------------------------------------
 * Runtime Validation (fail fast on misconfig)
 * ----------------------------------------------*/

/** Throws if RULES contain duplicates or invalid fields. */
function validateRules(rules) {
  const ids = new Set();
  for (const r of rules) {
    if (!r.id || typeof r.id !== 'string') throw new Error('Rule.id is required (string).');
    if (ids.has(r.id)) throw new Error(`Duplicate rule id: ${r.id}`);
    ids.add(r.id);

    if (!r.name) throw new Error(`Rule ${r.id}: name is required.`);
    if (!r.description) throw new Error(`Rule ${r.id}: description is required.`);
    if (typeof r.points !== 'number' || r.points < 0) {
      throw new Error(`Rule ${r.id}: points must be a non-negative number.`);
    }
    if (!r.metric) throw new Error(`Rule ${r.id}: metric is required.`);
    if (typeof r.threshold !== 'number' || r.threshold < 0) {
      throw new Error(`Rule ${r.id}: threshold must be a non-negative number.`);
    }
    if (typeof r.check !== 'function') {
      throw new Error(`Rule ${r.id}: check must be a function.`);
    }
  }
}
validateRules(RULES);

/** ---------------------------------------------
 * DB Layer: schema, indexes, upsert
 * ----------------------------------------------*/

/** Ensure base schema exists. Safe to call multiple times. */
function ensureSchema() {
  // Keep table schema minimal; business logic lives in app.
  db.exec(`
    CREATE TABLE IF NOT EXISTS achievements (
      id TEXT PRIMARY KEY,
      key TEXT NOT NULL,
      name TEXT NOT NULL,
      description TEXT NOT NULL,
      points INTEGER NOT NULL,
      icon TEXT NOT NULL,
      category TEXT NOT NULL,
      secret INTEGER NOT NULL DEFAULT 0
    );
  `);
}

/** Create indexes once; no-ops if already present. */
function ensureIndexes() {
  db.exec(`
    CREATE INDEX IF NOT EXISTS idx_achievements_key ON achievements(key);
    CREATE INDEX IF NOT EXISTS idx_achievements_category ON achievements(category);
    -- Optional composite index if you often filter list views by category + secret.
    CREATE INDEX IF NOT EXISTS idx_achievements_cat_secret ON achievements(category, secret);
  `);
}

/** Insert or update only presentational metadata; runtime logic stays in code. */
const UPSERT_SQL = `
INSERT INTO achievements (id, key, name, description, points, icon, category, secret)
VALUES (@id, @key, @name, @description, @points, @icon, @category, @secret)
ON CONFLICT(id) DO UPDATE SET
  key=excluded.key,
  name=excluded.name,
  description=excluded.description,
  points=excluded.points,
  icon=excluded.icon,
  category=excluded.category,
  secret=excluded.secret
`;

/** Convert a rule to a DB row, normalizing booleans to integers. */
function toRow(r) {
  return {
    id: r.id,
    key: r.key ?? r.id,
    name: r.name,
    description: r.description,
    points: Number(r.points) || 0,
    icon: r.icon,
    category: r.category,
    secret: r.secret ? 1 : 0,
  };
}

/** Public: seed/refresh achievement metadata safely and idempotently. */
export function seedAchievements() {
  ensureSchema();
  ensureIndexes();

  const stmt = db.prepare(UPSERT_SQL);
  const tx = db.transaction((rows) => {
    for (const r of rows) stmt.run(toRow(r));
  });

  try {
    tx(RULES);
  } catch (err) {
    // Surface enough context for observability while avoiding PII.
    const message = err instanceof Error ? err.message : String(err);
    throw new Error(`Failed to seed achievements: ${message}`);
  }
}

/** ---------------------------------------------
 * Evaluation API
 * ----------------------------------------------*/

/**
 * Calculate unlocks and in-progress rules for a given state.
 * @param {Record<string, number>} state - metrics map, e.g. { sales: 3, chats: 9 }
 * @param {{withMeta?: boolean, includeLocked?: boolean, sortBy?: 'points'|'progressPct'|'category' }} [options]
 */
export function evaluateAll(state, options = {}) {
  const { withMeta = false, includeLocked = true, sortBy = 'points' } = options;

  /** Build a normalized view for each rule */
  const rows = RULES.map((r) => {
    const res = r.check(state);
    const progress = Math.max(0, res.progress);
    const target = Math.max(0, res.target);
    const progressPct = target > 0 ? Math.min(1, progress / target) : res.done ? 1 : 0;

    const base = {
      id: r.id,
      done: res.done,
      progress,
      target,
      progressPct,
      points: r.points,
    };
    return withMeta
      ? { ...base, meta: { name: r.name, description: r.description, icon: r.icon, category: r.category, key: r.key ?? r.id, secret: !!r.secret } }
      : base;
  });

  /** Optional filter */
  const filtered = includeLocked ? rows : rows.filter((x) => x.done);

  /** Optional sort */
  const sorted = [...filtered].sort((a, b) => {
    switch (sortBy) {
      case 'progressPct': return b.progressPct - a.progressPct;
      case 'category': {
        const ca = withMeta ? a.meta.category : '';
        const cb = withMeta ? b.meta.category : '';
        return String(ca).localeCompare(String(cb));
      }
      case 'points':
      default: return b.points - a.points;
    }
  });

  /** Final shape for backward compatibility + richer data */
  const unlocked = sorted
    .filter((x) => x.done)
    .map((x) => withMeta ? { id: x.id, points: x.points, meta: x.meta } : { id: x.id, points: x.points });

  const inProgress = sorted
    .filter((x) => !x.done)
    .map((x) =>
      withMeta
        ? { id: x.id, progress: x.progress, target: x.target, progressPct: x.progressPct, points: x.points, meta: x.meta }
        : { id: x.id, progress: x.progress, target: x.target, progressPct: x.progressPct, points: x.points }
    );

  return { unlocked, inProgress };
}
